{"version":3,"sources":["webpack://formform/webpack/universalModuleDefinition","webpack://formform/./node_modules/big-integer/BigInteger.js","webpack://formform/webpack/bootstrap","webpack://formform/webpack/runtime/define property getters","webpack://formform/webpack/runtime/hasOwnProperty shorthand","webpack://formform/webpack/runtime/node module decorator","webpack://formform/./src/lib/core/fcalc.js","webpack://formform/./node_modules/formsandlines-utils/lib/string.js","webpack://formform/./node_modules/formsandlines-utils/lib/array.js","webpack://formform/./node_modules/formsandlines-utils/lib/validation.js","webpack://formform/./src/common/helper.js","webpack://formform/./node_modules/formsandlines-utils/lib/object.js","webpack://formform/./src/lib/core/fform.js","webpack://formform/./src/lib/main.js","webpack://formform/./src/lib/core/fdna.js","webpack://formform/./node_modules/formsandlines-utils/lib/bigint.js"],"names":["root","factory","exports","module","define","amd","this","BASE","MAX_INT","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","v","radix","alphabet","caseSensitive","parseValue","parseBase","BigInteger","value","sign","isSmall","SmallInteger","NativeBigInt","isPrecise","n","Math","floor","arrayToSmall","arr","trim","length","compareAbs","i","createArray","x","Array","truncate","ceil","add","a","b","sum","l_a","l_b","r","carry","base","push","addAny","addSmall","l","subtract","difference","a_l","b_l","borrow","subtractSmall","multiplyLong","product","a_i","j","multiplySmall","shiftLeft","concat","multiplyKaratsuba","y","max","slice","d","c","ac","bd","abcd","multiplySmallAndArray","square","divModSmall","lambda","q","remainder","divisor","quotient","divModAny","self","Error","negate","abs","comparison","quotientDigit","shift","result","divisorMostSignificantDigit","divMod1","guess","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mod","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","divide","next","bigInt","modPow","prototype","Object","create","plus","subtractAny","minus","small","multiply","l1","l2","times","_multiplyBySmall","divmod","over","pow","toString","_0","_1","_2","isNegative","exp","isZero","modInv","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isPrime","strict","undefined","bits","bitLength","logN","log","toJSNumber","t","isProbablePrime","iterations","rng","randBetween","lastT","lastR","zero","newT","one","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","fn","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","String","shiftRight","remQuo","and","or","xor","LOBMASK_I","roughLOB","integerLogarithm","tmp","p","e","min","gcd","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","val","toBase","apply","map","valueOf","neg","Number","out","left","digit","toBaseString","stringify","join","parseStringValue","split","decimalPlace","indexOf","test","parseNumberValue","toArray","str","toJSON","parseInt","minusOne","lcm","isInstance","usedRNG","random","low","range","restricted","top","fromArray","hasOwnProperty","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","definition","key","o","defineProperty","enumerable","get","obj","prop","call","nmd","paths","children","FCalc","fx","fy","fVals","rel_logic","inv_logic","fA","fB","altInterpr","reEntry","lastOpen","fC","fD","fE","reEven","resEven","zeros","firstUndef","uFORM","iFORM","calcfrom","rel","inv","repeat","index","iRev","case0","case1","cont","implL","implR","pre","post","pad","num","size","s","flatten","reduce","flat","toFlatten","isArray","checkBracketMatching","openBr","closeBr","acc","curr","idx","NaN","createValidation","errorMsg","args","cata","branch","success","error","collapseLiterals","sep","repl","checkLiteralMatching","filter","substr","getBracketUnits","formula","br","open","close","matches","reEntries","match","RegExp","reducedFormula","pattern","replace","VARCODE","VARCODE_REV","bijective","keys","k","assign","reverseMapping","FForm","_form","form","getValidForm","space","type","calc","isNaN","nestedVals","fReEntry","nested","reEntryNumber","altInterpretation","unmarked","vars","getVariables","vnum","vals","interKey","interprVals","interpr","var","interCalc","interpret","interprForm","JSON","parse","traverseForm","fBranch","symbol","super","jsonStr","convFromLinear","json","console","cleanFormula","cleanLinear","constructFromLinear","inQuote","inSlash","char","compAll","countDepth","parts","prevChar","comp","content","reNested","includes","startsWith","_content","typeCharSum","reParts","reForm","options","reChild","nestedForm","addEmptyReChildSpace","lastNested","refForm","targetForm","runningIndex","refBranch","targetBranch","constructNested","expandRE","expand_reEntry","sort","func","breakTrav","formStr","varorder","decodeVars","encodeVars","encStr","decodePattern","revCode","varPart","modPart","code","escapeRegExp","string","ptn","varList","input","isValidFormula","isValidJSONForm","validations1","every","validation","data","cleanInput","roundBrUnits","curlyBrUnits","subForm","isValidReEntry","entries","optList","selList","opt","selList_unique","Set","varsForm","v_a","some","v_b","parseLinear","isValidDNA","dna","pop","results","totalVarsFromDNA","from","_","calcAll","getDNAparts","reOrderVars","values","generateVarNames","univ","universe_n","term","int","quat","dnaLen","minDnaLen","strLen","output","encode","formDNA","decode","value_bin","intToDNA","limitSize","convDefaultVarorder","gapGrow","marginFunc","strokeW","dnaParts","arrB","arrA","matchDefaultVarOrder","reversedDNA","cellSize","margins","cell","w","h","tree","constructVmap","globalOptions","localOptions","inputArray","permute","res","item","perm","vmap","hideInputLabel","customLabel","inputList","qi","constructVmap_recursive","dnaHolon","vcount","subTree","gapSum","calcGapSum","qtn","len","sqrt","height","depth","order","position","scale","_varList","formMatchesVarList","_input","compareForm","requireMark","dnaMatchesForm","excludeList","candidate","univ1s","universe_1","iq","univN","univ1","message","formToDNA","form_parts"],"mappings":"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","file":"formform.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"formform\"] = factory();\n\telse\n\t\troot[\"formform\"] = factory();\n})(this, function() {\nreturn ","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","export default class FCalc {\n    \n    // ===================================================================\n    //     formform core module 'calc'\n    //     -- since 2018, by Peter Hofmann (formsandlines.eu)\n    // ===================================================================\n\n    constructor() {\n    };\n\n    static rel_logic(fx, fy) { // verified\n        /* FORM arithmetic for commutative relation: x y */\n        if ( fx > 3 || fx < 0 || fy > 3 || fy < 0 ) return -98;\n        else if ( fx === 0 || fy === 1 ) { \n            return fy; // C3 /Theorem 2\n        } \n        else if ( fy === 0 || fx === 1 ) { \n            return fx; // C3 /Theorem 2\n        }\n        else if ( fx === fy ) { \n            return fx; // C5 /Theorem 5\n        }\n        else if ( (fx === 2 && fy === 3) || (fx === 3 && fy === 2) ) { \n            return 1; // C2 /Theorem 13 + C3 /Theorem 2\n        }\n        return -99; // error code\n    };\n    static rel(...fVals) { // verified\n        /* Shortcut for relation with n variables: x_1 ... x_n */\n        if (fVals.length > 1) {\n            let val = 0;\n            for (let i in fVals) {\n                val = this.rel_logic( val,fVals[i] );\n            }\n            return val;\n        }\n        return -97; // error code\n    };\n\n    static inv_logic(fx) { // verified\n        /* FORM arithmetic for inversion/negation: (x) */\n        switch (fx) {\n        case 0:\n            return 1;\n        case 1:\n            return 0;\n        case 2:\n            return 3;\n        case 3:\n            return 2;\n        }\n        return -99; // error code\n    };\n    static inv(fx, n) { // verified\n        /* Shortcut for n inversions/negations: (x) */\n        if (n > 0) {\n            let val = fx;\n            for (let i=0; i<n; i++) {\n                val = this.inv_logic(val);\n            }\n            return val;\n        }\n        else return this.inv_logic(fx);\n        return -97; // error code\n    };\n\n\n    // ---------------------------\n    //  RE-ENTRY FORM CALCULATION\n    // ---------------------------\n\n    static uForm2(fA, fB, altInterpr=false) { // calculation verified (both interpr.)\n        return this.reEntry(undefined, false, altInterpr, fA, fB);\n    };\n    static iForm2(fA, fB, altInterpr=false) { // calculation verified (both interpr.)\n        return this.reEntry(undefined, true, altInterpr, fA, fB);\n    };\n    static uForm3(lastOpen, fA, fB, fC, altInterpr=false) { // calculation verified closed & open (both interpr.)\n        return this.reEntry(true, lastOpen, altInterpr, fA, fB, fC);\n    };\n    static iForm3(lastOpen, fA, fB, fC, altInterpr=false) { // calculation verified closed & open (both interpr.)\n        return this.reEntry(false, lastOpen, altInterpr, fA, fB, fC);\n    };\n    static uForm4(fA, fB, fC, fD, altInterpr=false) {\n        return this.reEntry(undefined, false, altInterpr, fA, fB, fC, fD);\n    };\n    static iForm4(fA, fB, fC, fD, altInterpr=false) {\n        return this.reEntry(undefined, true, altInterpr, fA, fB, fC, fD);\n    };\n    static uForm5(lastOpen, fA, fB, fC, fD, fE, altInterpr=false) {\n        return this.reEntry(true, lastOpen, altInterpr, fA, fB, fC, fD, fE);\n    };\n    static iForm5(lastOpen, fA, fB, fC, fD, fE, altInterpr=false) {\n        return this.reEntry(false, lastOpen, altInterpr, fA, fB, fC, fD, fE);\n    };\n\n    // static reEntry(... vars) {\n    //     return this.reEntry(false, false, vars);\n    // }\n    // static reEntry(reEven, ... vars) {\n    //     return this.reEntry(reEven, false, vars);\n    // }\n\n    static reEntry(reEven, lastOpen, altInterpr, ...fVals) {\n        /* FORM arithmetic for different self-equivalent re-entry FORMs\n         [Arguments] reEven: even re-entry-number? | lastOpen: last variable not crossed? | fVals: variables (0/1/2/3)\n\n         Note: calculation manually verified for \n         - (uFORM a1, res2) =((x)y)\n         - (iFORM a2, res2) ()=(a1x)y\n         - (iFORM b1, res3) [2|r|+1] ()=(((x)y)z) =((((((x)y)z)x)y)z)\n         - (iFORM b2, res3) [2|r|+1] ()=((b1x)y)z\n         - (uFORM c1, res3) [2|r|] =((((((x)y)z)x)y)z)\n         - (uFORM c2, res3) [2|r|] ()=((c1x)y)z\n         Should work with resolutions of 4, 5,  but needs verification.\n\n         My basic observations about self-equivalent re-entry FORMs:\n         - Every re-entry FORM needs to have an even number of crosses to be self-equivalent (uFORM):  = ((1)2) .\n           So with uneven resolutions, we always need to have an even re-entry number:  = ((((((1)2)3)1)2)3) .\n         - To be able to also have uneven re-entry numbers, either the resolution needs to be even\n           or we have to embed the re-entry FORM into a normal FORM that is one re-entry of that FORM:\n           () = (((1)2)3) <-> (((  = ((((((1)2)3)1)2)3) 1)2)3) .\n           These compositional re-entry FORMs are iFORMs, since they resolve to: (  = (()) ) .\n         - If the outmost cross of the FORM should be left out (open FORMs), this can only be done if we embed\n           a corresponding closed FORM of itself that either is or embeds its re-entry FORM (cases described above).\n           I believe the outmost (open) FORM is not being counted as a re-entry at all, since it's missing a cross.\n\n         This algorithm is based on the following rules/patterns/observations derived from \"uFORM iFORM\":\n         [1] If 1 is somewhere in the FORM, it will dominate all values in spaces deeper than m,\n             so the re-entry is obsolete and we can start calculate from this space. \n         [2] If there are 3/2 or 2/3 pairs in the FORM, the first term can be turned into 1, since\n             through C2 the second term can always be generated into its space, where 23 = 1.\n             Then we can proceed as in (1).\n         [3] If all variables are 0, we will have either a uFORM or iFORM, hence the value of the\n             FORM will be either 2 or 3, depending on the following cases:\n             - 2: closed,      resolution even, re-entry-number even/odd (a1)\n             - 2: closed/open, resolution odd,  re-entry-number even     (c1, c2)\n             - 3: open,        resolution even, re-entry-number even/odd (a2)\n             - 3: closed/open, resolution odd,  re-entry-number odd      (b1, b2)\n         Since [1][2][3] eliminate all other cases, all variables are now either 2 or 3 (and maybe 0s),\n         so using C2 as described above, only the last occasion of these variables need to be considered:\n         [4] If we use uFORM iFORM interpretation 2 (p.167) recursive identity ( mn <-> (())= ), C2 and C1\n              can be separated from 2/3 if there is an even number of crosses (or none) after the variable.\n             Then, depending on the FORM, we have either:\n             iFORM: (=(())) 2/3 <-> (2) 2/3  or\n             uFORM:  =(()) 2/3  <->  2 2/3\n         [5] If [4] does not apply or we decide for uFORM iFORM interpretation 1 (p.167): recursion instruction \n             ( mn -> =(()) ), we will have either variables of 2 or 3 which we cannot relate to , since\n             they need not be the same undetermined value. Using case distinction, we interpret the\n             last occasion of 2 or 3 as 0 and as 1, calculate everything with =2 and relate the results \n             using contravalence: ((x)y)((y)x) which yields the final result.\n        */\n        // check if arguments are actually defined\n        if (reEven === undefined) {\n            reEven = false;\n        }\n        if (lastOpen === undefined) {\n            lastOpen = false;\n        }\n\n        const resEven = (fVals.length%2 == 0); // even resolution?\n        let zeros = 0; // zero counter\n        let firstUndef = -1; // catches first mn/(mn)\n\n        // [3] determine if uFORM or iFORM\n        let uFORM = false;\n        let iFORM = false;\n        if (resEven) {\n            if (lastOpen) iFORM = true;\n            else uFORM = true;\n        }\n        else {\n            if (reEven) uFORM = true;\n            else iFORM = true;\n        }\n      \n        // check if there is 1/m somewhere in x_1  x_n\n        let calcfrom = -1;\n        for(let i=0; i<fVals.length; i++) {\n            const fx = fVals[i]; \n\n            if (fx == 1) {\n                calcfrom = i; // [1] if m is somewhere, set calculation start from there\n                break;\n            }\n            else if (fx == 0) zeros++; // [3] keep track of how many zeros there are\n            else if (fx == 2 || fx == 3) { // [2]\n                if(firstUndef == -1) firstUndef = i; // if there is a first 2/u or 3/i, remember\n                else if(fx != fVals[firstUndef]) {\n                    calcfrom = firstUndef; // if 3/2 or 2/3 pairs, set calculation form first undef. value\n                    break;\n                }\n            }\n        }\n      \n        if (zeros == fVals.length) {\n            // [3] in case all variables are n, just return the undefined/imaginary value of the FORM\n            if (iFORM) return 3;\n            else return 2;\n        }\n        if (calcfrom >= 0) {\n            // [1|2] if there is a 1/m somewhere in the form, we can easily calculate the rest from this point\n            let val = 1;\n            for(let i=calcfrom; i<fVals.length; i++) {      \n                if (lastOpen && i == fVals.length-1) {\n                    val = this.rel(val,fVals[i]); // if no cross on last var, don't invert\n                }\n                else val = this.inv( this.rel(val,fVals[i]) );\n            }\n            return val;\n        }\n      \n        // what remains, will only be either\n        // - (1) all variables are n/0 or mn/2   or\n        // - (2) all variables are n/0 or (mn)/3\n        // So we calculate from the last occasion of 2 or 3, because with C2 (degenerate) all else can be ignored\n\n        // for even closed re-entry-FORMs with uneven resolution (uFORM c1), we need to do the calculation twice\n        const repeat = (reEven && !resEven && !lastOpen)? 2:1;\n      \n        for(let i=(fVals.length*repeat)-1; i>=0; i--) {\n            const index = i%fVals.length; // repeated variable index\n\n            if (fVals[index] == 2 || fVals[index] == 3) {\n                const iRev = (fVals.length*repeat)-1 - i; // reverse index to easier check for interpretation 2 (see next)\n\n                if (altInterpr && ((lastOpen && iRev%2==0) || (!lastOpen && iRev%2==1))) {\n                    // uFORM iFORM interpretation 2: recursive identity ( =(()) <-> mn )\n                    // =(()) can be separated if there is an even number of crosses (or none) after the variable; this is the case if either:\n                    // - (1) the FORM is open and the backwards variable index is even      or\n                    // - (2) the FORM is closed and the backwards variable index is odd\n\n                    // to determine if the number of crosses between  and our var is even, we distinguish two cases:\n                    if (iFORM) return this.rel(3,fVals[index]); // iFORM: (=(()))x <-> (mn) x\n                    else return this.rel(2,fVals[index]);       // uFORM:  =(())x  <->  mn x\n                }\n                else {\n                    // [5] if everything else fails, use case distinction: uFORM iFORM (p.94); also according to:\n                    // uFORM iFORM (p.167) interpretation 1: recursion instruction ( =(()) and mn need to be differentiated)\n\n                    let case0 = 2; // re-entry =mn, because other mn=0\n                    if (lastOpen && !resEven && !reEven) case0 = this.inv(case0); // cross for integrated FORMs with uneven res. inside open FORMs (iFORM b2)\n                    for(let j=0; j<(fVals.length*repeat); j++) {\n                        let fx = 0; // all other values will be (degenerated to) zero\n                        if (j == i) {\n                            if(fVals[index] == 2) fx = 0; // last occasion of mn/2 will be interpreted as 0\n                            else fx = this.inv(0); // last occasion of (mn)/3 will be interpreted as (0)\n                        }\n                        if (lastOpen && j == fVals.length-1) case0 = this.rel(case0,fx); // if no cross on last var, don't invert\n                        else case0 = this.inv( this.rel(case0,fx) );\n                    }\n                    let case1 = 2; // re-entry =mn, because other mn=1\n                    if (lastOpen && !resEven && !reEven) case1 = this.inv(case1); // cross for integrated FORMs with uneven res. inside open FORMs (iFORM b2)\n                    for(let j=0; j<(fVals.length*repeat); j++) {\n                        let fx = 0; // all other values will be (degenerated to) zero\n                        if (j == i) {\n                            if(fVals[index] == 2) fx = 1; // last occasion of mn/2 will be interpreted as 1\n                            else fx = this.inv(1); // last occasion of (mn)/3 will be interpreted as (1)\n                        }\n                        if (lastOpen && j == fVals.length-1) case1 = this.rel(case1,fx); // if no cross on last var, don't invert\n                        else case1 = this.inv( this.rel(case1,fx) );\n                    }\n\n                    return this.cont( case0,case1 ); // contravalence of both cases\n                }\n\n            }\n        }\n      return -99; // error code\n    }; // end reEntry()\n\n\n    // ---------------------------\n    //  COMPLEX FORM CALCULATIONS\n    // ---------------------------\n\n    // - 2 VARIABLES\n\n    static implL(fx, fy) { // verified\n        /* FORM arithmetic for \"implication\": (x)y */\n        return this.rel( this.inv(fx),fy );\n    };\n    static implR(fx, fy) {\n        /* FORM arithmetic for \"implication\": x(y) */\n        return this.rel( fx,this.inv(fy) );\n    };\n\n    static pre(fx, fy) { // verified\n        /* FORM arithmetic for \"presection\"/\"decision\": ((x)y) */\n        return this.inv( this.implL(fx,fy) );\n    };\n    static post(fx, fy) { // verified\n        /* FORM arithmetic for \"postsection\"/\"decision\": (x(y)) */\n        return this.inv( this.implR(fx,fy) );\n    };\n\n    static cont(fx, fy) { // verified\n        /* FORM arithmetic for \"contravalence\"/\"either-or\": ((x)y) (x(y)) */\n        return this.rel( this.pre(fx,fy), this.post(fx,fy) );\n    };\n    static equiv(fx, fy) {\n        /* FORM arithmetic for \"equivalence\"/?: ( ((x)y) (x(y)) ) */\n        return this.inv( this.cont(fx,fy) );\n    };\n\n}","export function pad(num, size) {\n    /* pads 0s before number string\n       Source: https://stackoverflow.com/a/2998822\n       Credits to: InfinitiesLoop */\n\n    var s = num+\"\"; // converts number to string if not already a string\n    while (s.length < size) s = \"0\" + s;\n    return s;\n}\n\n// former String.prototype.replaceAll\nexport function replaceAll(str, find, replace, escapeMeta) {\n    /*  Modified from: https://stackoverflow.com/questions/1144783/how-to-replace-all-occurrences-of-a-string-in-javascript \n    Credits to: Sean Bright */\n    if(escapeMeta) find = escapeRegExp(find);\n    return str.replace(new RegExp(find, 'g'), replace);\n};\n\nexport function escapeRegExp(str) {\n    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n}\n\n// former String.prototype.addBefore\nexport function addBefore(str, index, replacement) {\n    return str.substr(0, index) + replacement+ str.substr(index);\n}\n\n// former String.prototype.replaceAt\nexport function replaceAt(str, index, replacement) {\n    return str.substr(0, index) + replacement+ str.substr(index + replacement.length);\n}\n\n/*  --------------------------------------------------------\n    Additions 01/2020 from:\n    https://observablehq.com/@formsandlines/js-toolbox\n*/\n\nexport const truncateStr = (str,limit,appendix='') => str.length > limit ? (str.substr(0,limit) + appendix) : str;\n\n\n/* Breaks string up in parts of length n (x <= n for the last part) \n   from: https://observablehq.com/@formsandlines/js-toolbox\n*/\nexport const breakStr = (str,n=1) => [...new Array(Math.ceil(str.length/n))].map((d,i) => str.substr(n*i,n));\n\n","export function flatten(arr) {\n    /* Source: https://stackoverflow.com/a/15030117 \n    Credits to: Noah Freitas */\n  return arr.reduce(function (flat, toFlatten) {\n    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\n  }, []);\n}\n\nexport function include(arr,obj) {\n    /*  Source: https://stackoverflow.com/a/143863\n    Credits to: Vinko Vrsalovic */\n    return (arr.indexOf(obj) != -1);\n}\n\nexport function arrayMoveItem(arr, from, to) {\n  arr.splice(to, 0, arr.splice(from, 1)[0]);\n}\n\n/*  --------------------------------------------------------\n    Additions 01/2020 from:\n    https://observablehq.com/@formsandlines/js-toolbox\n*/\n\nexport const permuteArray = inputArray => inputArray.reduce(function permute(res, item, key, arr) {\n  /* Permutation algorithm for arrays of arbitrary length\n     (credits & thanks to user monkey: https://stackoverflow.com/a/22063440) */\n    return res.concat(arr.length > 1 && arr.slice(0, key)\n      .concat(arr.slice(key + 1))\n      .reduce(permute, [])\n      .map(function(perm) { return [item].concat(perm); }) || [[item]]);\n}, []);","/*  --------------------------------------------------------\n    Additions 10/2020 from:\n    https://observablehq.com/@formsandlines/js-toolbox\n*/\n\nexport const checkBracketMatching = (str, openBr='(', closeBr=')') => {\n    if (str.length === 0) return true; // empty strings can't have brackets, so that's fine\n    return str.split('').reduce((acc,curr,idx,arr) => {\n      if (curr === openBr) acc++;\n      else if (curr === closeBr) {\n        if (acc === null) return NaN;\n        acc--;\n        }\n      if (idx === arr.length-1 && acc === null) return 0;\n      return acc;\n    },null) === 0 ? true : false;\n  };\n  \nexport const equalArrays = (arrA, arrB) => {\n    if (arrA === undefined || arrB === undefined) return false;\n    return arrA.length === arrB.length && arrA.every(a => arrB.some(b => a === b));\n}\n\nexport const createValidation = (fn, errorMsg) => (...args) => {\n    const result = fn(...args);\n    return {\n        cata: branch => result ? branch.success(result) : branch.error(errorMsg)\n    };\n};\n\nexport const collapseLiterals = (str, sep='\"', repl='') => {\n    if (!checkLiteralMatching(str, sep)) return null;\n    const strSep = str.split(sep);\n    return strSep.filter((substr,i,arr) => i % 2 === 0 || i === arr.length-1).join(repl);\n}\n\nexport const checkLiteralMatching = (str, sep='\"') => {\n    const strSep = str.split(sep);\n    return strSep.length % 2 === 1;\n};\n\nexport const getBracketUnits = (formula, br={open:'{', close:'}'}, matches=[]) => {\n    const reEntries = formula.match(new RegExp(`\\\\${br.open}[^${br.open}${br.close}]*?\\\\${br.close}`, 'g'));\n    if (!reEntries) return matches;\n\n    const reducedFormula = reEntries.reduce((str, pattern) => str.replace(pattern, ''),formula);\n\n    return getBracketUnits(reducedFormula, br, [...matches, ...reEntries]);\n}","import { reverseMapping } from 'formsandlines-utils';\n\n/*  --------------------------------------------------------\n    Additions 01/2020 from:\n    https://observablehq.com/@formsandlines/formform-toolbox \n*/\n\nexport const VARCODE = ({'a':'', 'b':'', 'c':'', 'd':'', 'e':'', 'f':'', 'g':'', 'h':'', 'i':'', 'j':'', 'k':'', 'l':'', 'm':'', 'n':'', 'o':'', 'p':'', 'q':'', 'r':'', 's':'', 't':'', 'u':'', 'v':'', 'w':'', 'x':'', 'y':'', 'z':'', 'alt':'', '2r':'', '2r+1':''});\n\nexport const VARCODE_REV = reverseMapping(VARCODE,true);","export function traverse(o,func) {\n    /*  Source: https://stackoverflow.com/questions/722668/traverse-all-the-nodes-of-a-json-object-tree-with-javascript \n    Credits to: TheHippo */\n    for (var i in o) {\n        func.apply(null,[i,o[i]]);  // null or this?\n        if (o[i] !== null && typeof(o[i])==\"object\") {\n            //going one step down in the object tree!!\n            traverse(o[i],func);\n        }\n    }\n}\n\n/*  --------------------------------------------------------\n    Additions 01/2020 from:\n    https://observablehq.com/@formsandlines/js-toolbox\n*/\n\nexport const reverseMapping = (o,bijective=false) => Object.keys(o).reduce((r, k) => Object.assign(r, { [o[k]]: (bijective ? k : (r[o[k]] || []).concat(k)) }), {}); // modified from answer by Nina Scholz: https://stackoverflow.com/a/45728850","import { pad, flatten, include, createValidation, checkBracketMatching, collapseLiterals, getBracketUnits } from 'formsandlines-utils';\nimport { VARCODE, VARCODE_REV } from '../../common/helper';\nimport FCalc from './fcalc';\n\nexport default class FForm extends FCalc {\n\n    // ===================================================================\n    //     formform core module 'form'\n    //     -- since 2018, by Peter Hofmann (formsandlines.eu)\n    // ===================================================================\n\n    constructor() {\n    };\n\n    // ----------------------------------------------------\n    // Form Calculation\n    // ----------------------------------------------------\n\n    static calc(_form) {\n        /* Calculates a given form recursively \n\n        Note: Do NOT use this function for formulas with variables!\n              Assumes x=0 for all variables. Use interCalc() instead.\n        */\n\n        let fx = 0;\n        // make sure to have a json form, if not: try to convert\n        const form = this.getValidForm(_form);\n\n        for (let i in form.space) {\n            if (form.space[i].type === 'form') {\n                fx = this.rel( fx,this.calc(form.space[i]) );\n            }\n            else if (form.space[i].type === 'const') {\n                fx = this.rel( fx,form.space[i].value );\n            }\n            else if (form.space[i].type === 'var') {\n                if(!isNaN(form.space[i].value)) fx = this.rel( fx,form.space[i].value );\n            }\n            else if (form.space[i].type === 'unclear') {\n                fx = this.rel( fx,form.space[i].value );\n            }\n            else if (form.space[i].type === 'reEntry') {\n                let nestedVals = [];\n                const fReEntry = form.space[i];\n\n                for (let j in fReEntry.nested) {\n                    nestedVals = [...nestedVals, this.calc(fReEntry.nested[j])];\n                }\n                // for even resolutions (total nested arguments), reEntry number will be undefined\n                // since it doesn't matter if its even or odd\n                const reEntryNumber = (fReEntry.nested.length % 2 === 0) ? undefined : fReEntry.reEven;\n                \n                // notation reading: {deepest, ..., shallowest}  use nestedVals.reverse() to reverse variables\n                fx = this.rel( fx,this.reEntry(reEntryNumber, fReEntry.lastOpen, fReEntry.altInterpretation, ...nestedVals) );\n            }\n        }\n        if(form.unmarked) return fx;\n        else return this.inv( fx );\n    };\n\n    static calcAll(_form) {\n        /* Interpret and calculate all possible values for the form\n           (refactored: 10.10.2020)\n        */\n        const form = this.getValidForm(_form);\n\n        const vars = this.getVariables(form);\n        const vnum = vars.length;\n        const vals = {};\n\n        if (vnum < 1) {\n            vals['Result'] = this.calc(form);\n            return vals;\n        }\n\n        const interKey = ''+vars.join()+';';\n        \n        for (let i=0; i < 4**vnum; i++) {\n            const interprVals = pad(i.toString(4), vnum);\n            const interpr = interprVals.split('').map((val,n) => ({var: vars[n], value: parseInt(val)}));\n\n            vals[interKey+interprVals] = this.interCalc(form, interpr);\n        }\n\n        return vals;\n    };\n\n    static interCalc(form, interpr) {\n        /* Interprets a form and calculates the result of the interpretation */\n\n        return this.calc( this.interpret(form, interpr) );\n    };\n\n    static interpret(_form, interpr) {\n        /* Interprets a form with specified values for each variable\n\n        interpr: [{var: 'x', value: n}, ]\n        */\n        const form = this.getValidForm(_form);\n\n        const interprForm = JSON.parse(JSON.stringify(form)); // clone form\n\n        this.traverseForm(interprForm, function(fBranch) {\n            const space = fBranch.space;\n\n            for (let i in space) {\n                if (space[i].type === 'var') {\n                    for (let v in interpr) {\n                        if (space[i].symbol === interpr[v].var) {\n\n                            space[i].value = interpr[v].value;\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n\n        return interprForm;\n    };\n\n    // ----------------------------------------------------\n    // Extensions of FCalc\n    // ----------------------------------------------------\n\n    static rel_logic(fx, fy) {\n        if(typeof(fx) === Array || typeof(fy) === Array) {\n            return null;\n        }\n        return super.rel_logic(fx, fy);\n    };\n    static rel(...fVals) {\n        return super.rel(...fVals);\n    };\n\n    static inv_logic(fx) {\n        if(typeof(fx) === Array) {\n            return null;\n        }\n        return super.inv_logic(fx);\n    };\n    static inv(fx, n) {\n        return super.inv(fx, n);\n    };\n\n    // ----------------------------------------------------\n    // Conversions\n    // ----------------------------------------------------\n\n    static parseLinear(formula) {\n        /* Converts from paranthesis notation into JSON string and parses as JSON object */\n\n        // convert the formula into a JSON string\n        const jsonStr = this.convFromLinear(formula);\n\n        // try parsing the string as a JSON object\n        let json = null;\n        try {\n            json = JSON.parse(jsonStr);\n        } catch(e) {\n            console.log(e);\n        }\n\n        return json;\n    }\n\n    static convFromLinear(formula) {\n        // clean formula string from whitespace\n        const cleanFormula = this.cleanLinear(formula);\n        const arr = this.constructFromLinear(cleanFormula);\n        return flatten(arr).join('');\n    }\n\n    static cleanLinear(formula) {\n        let cleanFormula = '';\n        let inQuote = false;\n        let inSlash = false;\n\n        for (let i in formula) {\n            const char = formula[i];\n            if(typeof(char) !== \"string\") break; // prototype hacks\n\n            if (char === '\"' && !inSlash) inQuote = !inQuote;\n            if (char === '/' && !inQuote) inSlash = !inSlash;\n\n            // omit whitespace outside of quotes\n            if (char === ' ') {\n                if (inQuote ||inSlash) cleanFormula += char;\n            }\n            else cleanFormula += char;\n        }\n        return cleanFormula;\n    }\n\n    static constructFromLinear(formula) {\n        /* Converts from paranthesis notation to JSON-form */\n\n        let compAll = [];\n        let unmarked = true;\n\n        // check for all enclosing outer form\n        let countDepth = 0;\n        let inQuote = false;\n        let inSlash = false;\n        for (let i in formula) {\n            const char = formula[i];\n            if(typeof(char) !== \"string\") break; // prototype hacks\n\n            if (!inQuote && !inSlash) {\n                if (char === '(') {\n                    if ((countDepth == 0) && (i != 0)) break;\n                    countDepth++;\n                }\n                else if (char === ')') {\n                    countDepth--;\n                    if (countDepth == 0) {\n                        if (i == formula.length-1) {\n                            unmarked = false;\n                            break;\n                        }\n                        else break;\n                    }\n                }\n            }\n            if (char === '\"' && !inSlash) inQuote = !inQuote;\n            if (char === '/' && !inQuote) inSlash = !inSlash;\n        }\n\n        compAll = [...compAll, '  {'];\n        compAll = [...compAll, '\"type\":\"form\",'];\n\n        if (unmarked) compAll = [...compAll, '\"unmarked\":true,'];\n        else formula = formula.slice(1,formula.length-1);\n\n        compAll = [...compAll, '\"space\":['];\n\n\n        let parts = [''];\n\n        countDepth = 0;\n        inQuote = false;\n        inSlash = false;\n\n        const reChar = '';\n        const optChar = '';\n        const nestChar = '';\n\n        for (let i in formula) {\n            let char = formula[i];\n            const prevChar = formula[i-1];\n            if(typeof(char) !== \"string\") break; // prototype hacks\n            \n            if (!inQuote && !inSlash) {\n                if (char === ')' ||char === '}') countDepth--;\n                if (char === '(' ||char === '{') {\n                    \n                    if (countDepth === 0) {\n                        // first (x) doesn't need to be separated\n                        if (i > 0) parts = [...parts, ''];\n                    }\n                    countDepth++;\n                }\n                else if ( (prevChar === ')' ||prevChar === '}') && !(char === ')' ||char === '}') ) {\n                    // if char follows (x), separate; but not if it is another ')'\n                    if (countDepth === 0) parts = [...parts, ''];\n                }\n                // unique separation chars for re-entry forms for easy splitting\n                if (countDepth === 1 && char === ',') char = nestChar;\n                else if (countDepth === 1 && char === '|') char = optChar;\n                else if (countDepth === 1 && char === '@') char = reChar;\n            }\n            if (char === '\"' && !inSlash) inQuote = !inQuote;\n            if (char === '/' && !inQuote) inSlash = !inSlash;\n            // add char to the latest pushed part\n            parts[parts.length-1] += char;\n        }\n        \n        for (let i in parts) {\n\n            if (parts[i][0] === '(') { \n                // if part is form\n                let comp = [this.constructFromLinear(parts[i])];\n\n                parts[i] = comp.slice();\n            }\n            else if (parts[i][0] === '{') {\n                // else if part is re-entry form\n\n                let comp = ['  {'];\n                comp = [...comp, '\"type\":\"reEntry\",'];\n\n                const content = parts[i].slice(1,parts[i].length-1);\n                let reNested = undefined;\n\n                if (content.includes(reChar)) {\n                    // new re-entry syntax\n                    const altInterpr = content.startsWith(`alt${optChar}`);\n                    const _content = altInterpr ? content.slice(4,) : content.slice();\n\n                    let type = [-1,-1];\n                    if (_content.startsWith(`..${reChar}._`)) type = [3,1]\n                    else if (_content.startsWith(`..${reChar}.`)) type = [3,0]\n                    else if (_content.startsWith(`..${reChar}_`)) type = [2,1]\n                    else if (_content.startsWith(`..${reChar}`)) type = [2,0]\n                    else if (_content.startsWith(`${reChar}_`)) type = [0,1]\n                    else if (_content.startsWith(reChar)) type = [0,0]\n\n                    const typeCharSum = type[0] + type[1] + 1;\n                    reNested = _content.slice(typeCharSum,).split(nestChar);\n\n                    if (reNested.length % 2 === 0) {\n                        comp = [...comp, '\"reEven\":\"undefined\",'];\n                    }\n                    else if (type[0] === 2) comp = [...comp, '\"reEven\":true,'];\n                    else comp = [...comp, '\"reEven\":false,'];\n\n                    if (type[1] > 0) comp = [...comp, '\"lastOpen\":true,'];\n                    else comp = [...comp, '\"lastOpen\":false,'];\n\n                    if (altInterpr) comp = [...comp, '\"altInterpretation\":true,'];\n                    else comp = [...comp, '\"altInterpretation\":false,'];\n                }\n                else {\n                    // old re-entry syntax\n                    const reParts = content.split(optChar);\n\n                    reNested = reParts[reParts.length-1].split(nestChar);\n\n                    if (reNested.length % 2 === 0) {\n                        comp = [...comp, '\"reEven\":\"undefined\",'];\n                    } \n                    else {\n                        if (reParts[0] === '2r' || reParts[1] === '2r' || reParts[2] === '2r') comp = [...comp, '\"reEven\":true,'];\n                        else comp = [...comp, '\"reEven\":false,'];\n                    }\n\n                    if (reParts[0] === 'open' || reParts[1] === 'open' || reParts[2] === 'open') comp = [...comp, '\"lastOpen\":true,'];\n                    else comp = [...comp, '\"lastOpen\":false,'];\n\n                    if (reParts[0] === 'alt' || reParts[1] === 'alt' || reParts[2] === 'alt') comp = [...comp, '\"altInterpretation\":true,'];\n                    else comp = [...comp, '\"altInterpretation\":false,'];\n                }\n\n                comp = [...comp, '\"nested\":['];\n\n                for (let n in reNested) {\n                    comp = [...comp, this.constructFromLinear(reNested[n]) ];\n                    if (n < reNested.length-1) comp = [...comp, ','];\n                    // reNested[n] = this.constructFromLinear( reNested[n] );\n                }\n\n                comp = [...comp, ']}  '];\n\n                parts[i] = comp.slice();\n            }\n            else {\n                // else we have variables/constants\n\n                let comp = [];\n\n                let vars = [];\n                let inQuote = false;\n                let inSlash = false;\n\n                for (let j in parts[i]) {\n                    const char = parts[i][j];\n                    if(typeof(char) !== \"string\") break; // prototype hacks\n\n                    if (char === '\"' && !inSlash) {\n                        inQuote = !inQuote;\n                        // mark quoted string with a '' for identification\n                        if (inQuote) vars = [...vars, ''];\n                    }\n                    else if (char === '/' && !inQuote) {\n                        inSlash = !inSlash;\n                        // mark unclear form with a '' for identification\n                        if (inSlash) vars = [...vars, ''];\n                    }\n                    else {\n                        if (!inQuote && !inSlash) vars = [...vars, ''];\n                        // quote chars inside slashes will be escaped to not interfere with JSON syntax\n                        if (char === '\"' && inSlash) vars[vars.length-1] += '\\\\' + char;\n                        else vars[vars.length-1] += char;\n                    }\n                }\n\n                for (let v in vars) {\n                    if(typeof(vars[v]) !== \"string\") break; // prototype hacks\n\n                    comp = [...comp, '  {'];\n                    if (!isNaN(vars[v]) && vars[v].length > 0 \n                        && vars[v][0] !== '' && vars[v][0] !== '') {\n                        comp = [...comp, '\"type\":\"const\",']; \n                        comp = [...comp, '\"value\":'];\n                        comp = [...comp, vars[v]];\n                    }\n                    else if (vars[v][0] === '') {\n                        comp = [...comp, '\"type\":\"unclear\",'];\n                        comp = [...comp, '\"value\":2,'];\n                        comp = [...comp, '\"symbol\":'];\n                        comp = [...comp, '\"'+vars[v].slice(1)+'\"'];\n                    }\n                    else {\n                        comp = [...comp, '\"type\":\"var\",'];\n                        comp = [...comp, '\"value\":\"*\",'];\n                        comp = [...comp, '\"symbol\":'];\n                        if(vars[v][0] === '') comp = [...comp, '\"'+vars[v].slice(1)+'\"'];\n                        else comp = [...comp, '\"'+vars[v]+'\"'];\n                    }\n                    comp = [...comp, '}  '];\n                    if (v < vars.length-1) comp = [...comp, ','];\n                }\n\n                parts[i] = comp.slice();\n            } // end else\n\n            compAll = [...compAll, parts[i]];\n            if (i < parts.length-1) compAll = [...compAll, ','];\n        }\n\n        compAll = [...compAll, ']}  '];\n\n        return compAll;\n    }\n\n\n    static constructNested(reForm, options={}) {\n        /* Constructs a (real) nested form structure from the .nested array of the original re-entry json */\n\n        // >>> should be rewritten completely to get rid of all the mutation!\n        \n        let space = reForm.space = [];\n        reForm.nested.reverse(); // MUST be reversed, because notation: {deepest, ..., shallowest}\n\n        for(let i in reForm.nested) {\n            if (i > 0) {\n                // prepend the reEntry nesting before everything else in the space\n                space.unshift( {type: 'form', reChild: true, space: []} ); // space.push <- order last\n                const nestedForm = space[0]; // space[space.length-1] <- order last\n                \n                if(!reForm.nested[i].unmarked) nestedForm.space.push(reForm.nested[i]);\n                else {\n                    // nestedForm.space.push(reForm.nested[i]);\n                    nestedForm.space.push(...reForm.nested[i].space); // push(reForm.nested[i]) for grouping\n                }\n\n                space = nestedForm.space;\n            }\n            else {\n                if(!reForm.nested[i].unmarked) space.push(reForm.nested[i]);\n                // else space.push(reForm.nested[i]);\n                else space.push(...reForm.nested[i].space); // push(reForm.nested[i]) for grouping\n            }\n\n            if (options.addEmptyReChildSpace && (space.length === 0)) {\n                space.push( {type: 'space'} );\n            }\n        }    \n\n        // we need to add a point of re-entry to the last nested form\n        // first, lets assume this is the form itself\n        let lastNested = reForm;\n        \n        if(reForm.space.length > 0) {\n            // then loop until the last reChild is found and make this our last nested form\n            \n            while (lastNested.space[0].hasOwnProperty('reChild')) {        \n                lastNested = lastNested.space[0];\n                if (lastNested.space.length < 1) break; // prevent errors when nothing is found\n            }\n        }\n        // for open re-entries, we need to add another nesting (see uFORM iFORM for reference)\n        if(reForm.lastOpen) {\n            lastNested.space.unshift( {type: 'form', reChild: true, space: []} );\n            // then add the re-entry point to either space\n            lastNested.space[0].space.unshift( {type: 'reEntryPoint'} );\n        }\n        else lastNested.space.unshift( {type: 'reEntryPoint'} );\n\n        // last, delete the nested structure, we don't need it anymore\n        delete reForm.nested;\n        return reForm;\n    }\n\n    static expand_reEntry(_form, options={}) {\n        // >>> should be rewritten completely to get rid of all the mutation!\n        const refForm = this.getValidForm(_form);\n        const targetForm = JSON.parse(JSON.stringify(refForm)); // copy json object without identifying it\n\n        // we must keep a running index to not confuse identical forms while reconstructing the reEntries\n        // Note: this should be done more efficiently in the future\n        let runningIndex = 0;\n        this.traverseForm(refForm, function(branch) { branch.runningIndex = runningIndex, runningIndex++; });\n        runningIndex = 0;\n        this.traverseForm(targetForm, function(branch) { branch.runningIndex = runningIndex, runningIndex++; });\n\n        this.traverseForm(refForm, function(refBranch) {\n\n            if(refBranch.type === 'reEntry') {\n                this.traverseForm(targetForm, function(targetBranch) {\n\n                    if( (JSON.stringify(refBranch) === JSON.stringify(targetBranch)) && \n                            (refBranch.runningIndex === (targetBranch.hasOwnProperty('runningIndex') ? targetBranch.runningIndex : null)) ) {\n                        targetBranch = this.constructNested(targetBranch, options);\n                        return true;\n                    }\n                });\n\n            }\n        });\n        // delete running index property\n        this.traverseForm(targetForm, function(branch) { delete branch.runningIndex; });\n\n        return targetForm;\n    }\n\n\n    // ----------------------------------------------------\n    // Representation\n    // ----------------------------------------------------\n\n    static jsonString(_form, expandRE=false) {\n        /* returns json-representation of the specified FORM */\n        const form = this.getValidForm(expandRE ? this.expand_reEntry(_form) : _form);\n    \n        return JSON.stringify(form, undefined, 2);\n    }\n\n    // ----------------------------------------------------\n    // Helper\n    // ----------------------------------------------------\n\n    static getVariables(_form) {\n        /* parses a FORM to get all of its variables and sorts them using the JS Array.sort() method\n        which sorts by comparing UTF-16 code unit values.\n        Note: By convention, the process of deriving formDNA from a given FORM involves ordering of the extracted variables by this same sorting method, if no special ordering is specified. */\n        const form = this.getValidForm(_form);\n\n        let vars = [];\n        this.traverseForm(form, function(fBranch) {\n            const space = fBranch.space;\n\n            for (let i in space) {\n                if (space[i].type === 'var') {\n                    if (!include(vars, space[i].symbol)) {\n                        vars = [...vars, space[i].symbol];\n                    }\n                }\n            }\n        });\n        return vars.sort();\n    };\n\n    static traverseForm(form,func) {\n        /* traverses only form-types in a json tree */\n        const breakTrav = func.apply(this,[form]);\n\n        if (form.space) { // form.type: 'form'\n            if (form.space.length > 0) {\n                for (let i in form.space) {\n                    if (form.space[i].type === 'form' || form.space[i].type === 'reEntry') {\n                        const breakLoop = this.traverseForm(form.space[i],func);\n                        if (breakLoop) break;\n                    }\n                }\n            }\n        }\n        else if (form.nested) { // form.type: 'reEntry'\n            if (form.nested.length > 0) {\n                for (let i in form.nested) {\n                    const breakLoop = this.traverseForm(form.nested[i],func);\n                    if (breakLoop) break;\n                }\n            }\n        }\n        else console.log('ERROR: Not a form!');\n\n        return breakTrav;\n    };\n\n    /*  --------------------------------------------------------\n        Additions 01/2020 from:\n        https://observablehq.com/@formsandlines/formform-toolbox \n    */\n\n    static getTotalVars (formStr) {\n        /* gets total variable number of a FORM */\n        return this.getVariables(formStr.substr()).length;\n    };\n\n    static reOrderVars (formula, varorder) {\n        /* re-orders variables in a formula to match an ordering pattern */\n        return this.decodeVars( this.encodeVars(formula, varorder) );\n    };\n\n    static decodeVars (encStr, decodePattern=undefined) {\n      /* decodes variables in an encoded formula string with an optional decode pattern */\n      let revCode = VARCODE_REV;\n      if (decodePattern) {\n        const keys = Object.keys(VARCODE_REV);\n        const varPart = keys.slice(0,decodePattern.length);\n        const modPart = keys.slice(-3);\n        \n        revCode = varPart.concat(modPart).reduce( (code,key,i) => ({...code, \n            [key]: i < decodePattern.length ? decodePattern[i] : VARCODE_REV[key], }),{});\n      }\n\n      return encStr.split('')\n                .map(c => Object.keys(revCode).indexOf(c) > -1 ? revCode[c] : c).join('');\n    };\n\n    static encodeVars (formula, varorder=undefined) {\n      /* encodes variables in a formula string according to a given variable order (array) */\n      if (!varorder) varorder = this.getVariables(formula);\n      \n      function escapeRegExp(string) { // thx to CoolAJ86: https://stackoverflow.com/a/6969486\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n      }\n      \n      const fixPtn = {alt: 'alt(?=\\|)', rEven: '2r(?=\\|)', rOdd: '2r+1(?=\\|)'};\n      const ptn = v => {\n        if (v.length > 1) return `\\\"${escapeRegExp(v)}\\\"`; // (?<=\\\")(${v})(?=\\\")\n        return `${escapeRegExp(v)}`;\n      };\n      \n      return varorder\n        .reduce((encStr,v,i) => encStr\n                .replace(new RegExp(fixPtn.alt, 'g'),VARCODE['alt'] )\n                .replace(new RegExp(fixPtn.rEven, 'g'),VARCODE['2r'])\n                .replace(new RegExp(fixPtn.rOdd, 'g'),VARCODE['2r+1'])\n                .replace(new RegExp(ptn(v), 'g'),(Object.keys(VARCODE_REV)[i]) )\n                         , formula );\n    };\n\n\n    /*  --------------------------------------------------------\n        New Additions 01/2020:\n    */\n\n    static matchDefaultVarOrder (varList) {\n        /* Helper to match default orderings for calculation and vmaps */\n        if (varList.join('') === 'ELR') return ['L','E','R'];\n        if (varList.join('') === '+-LR') return ['-','L','R','+'];\n        if (varList.join('') === '+-ELR') return ['-','L','E','R','+'];\n        return varList;\n    }\n\n    /*  --------------------------------------------------------\n        New Additions 10/2020:\n    */\n\n    static isValidForm (input, options){\n        /* Checks if an input is a valid formula or JSON-FORM */\n\n        return typeof(input) === 'string' ? \n            isValidFormula(input, options) : isValidJSONForm(input, options);\n    }\n\n    static isValidFormula (input, options) {\n        /* Checks if an input is a valid formula */\n        // const { } = { ...options };\n\n        let validations1 = [\n            createValidation(() => typeof(input) === 'string',\n                'Formula input is not of type string'),\n        ];\n        if (input.length > 0) validations1 = [...validations1,\n            createValidation(\n                () => {\n                    return !!collapseLiterals(input, '\"') && !!collapseLiterals(input, '/');\n                    // const sansLiterals = collapseLiterals(input, '\"');\n                    // return sansLiterals ? checkLiteralMatching(sansLiterals, '/') : false;\n                },\n                'Number of quotes for literal variables (e.g.: \"x\") or number of slashes for unclear FORMs (e.g.: /x/) don\\'t match'),\n            // createValidation(\n            //     () => {\n                    // let openSep = '', closeSep = '';\n                    // const dirUnclForms = input.split('/').reduce((acc,curr,idx) => {\n                    //     return acc + (idx % 2 === 1 ? openSep : closeSep) + curr\n                    // });\n                    // const unclFormUnits = getBracketUnits(dirUnclForms, {open: openSep, close: closeSep});\n\n                    // return unclFormUnits.every(unclForm => unclForm.split('\"').length < 2); \n\n                    // let openSep = '', closeSep = '';\n                    // const dirLiterals = input.split('\"').reduce((acc,curr,idx) => {\n                    //     return acc + (idx % 2 === 1 ? openSep : closeSep) + curr\n                    // });\n                    // const literalUnits = getBracketUnits(dirLiterals, {open: openSep, close: closeSep});\n\n                    // literalUnits.every(literal => )\n                // },\n                // 'Number of quotes for literal variables (e.g.: \"x\") don\\'t match'),\n        ];\n        validations1.every(validation => validation().cata({\n            error: e => { throw new Error(e); },\n            success: data => data,\n        }) );\n\n        if (input.length > 0) {\n            const cleanInput = collapseLiterals( collapseLiterals(input, '\"'), '/');\n\n            const validations2 = [\n                createValidation(\n                    () => checkBracketMatching(cleanInput, '(', ')'),\n                    'Number or opening/closing order of parantheses in formula don\\'t match'),\n                createValidation(\n                    () => checkBracketMatching(cleanInput, '{', '}'),\n                    'Number or opening/closing order of curly brackets in formula don\\'t match'),\n            ];\n\n            validations2.every(validation => validation().cata({\n                error: e => { throw new Error(e); },\n                success: data => data,\n            }) );\n\n            const roundBrUnits = getBracketUnits(cleanInput, {open: '(', close: ')'});\n            const curlyBrUnits = getBracketUnits(cleanInput, {open: '{', close: '}'});\n\n            const validations3 = [\n                createValidation(\n                    () => roundBrUnits.every(subForm => checkBracketMatching(subForm, '{', '}'))\n                       && curlyBrUnits.every(subForm => checkBracketMatching(subForm, '(', ')')),\n                    'Opening/closing of parantheses overlaps with opening/closing of curly brackets in formula (e.g.: ({a)b})'),\n                createValidation(\n                    () => curlyBrUnits.every(reEntry => this.isValidReEntry(reEntry)),\n                    'Option part of one or more re-entry constructions is not well-formed'),\n            ];\n\n            validations3.every(validation => validation().cata({\n                error: e => { throw new Error(e); },\n                success: data => data,\n            }) );\n        }\n\n        return true;\n    }\n\n    static isValidReEntry (input, options) {\n        /* Checks if an input is a valid re-entry construction */\n        // const { } = { ...options };\n\n        const parts = input.slice(1,-1).split('|');\n\n        if (parts.length > 1) {\n            const entries = parts.filter((p,i,arr) => i < arr.length-1);\n            const optList = ['alt','open','2r','2r+1'];\n\n            const selList = entries.reduce((acc,str) => [...acc, optList.filter(opt => str === opt)[0]],[] ).filter(opt => opt);\n\n            const selList_unique = [...new Set(selList)];\n\n            const validations = [\n                createValidation(\n                    () => selList_unique.length === entries.length,\n                    'One or more re-entry constructions have invalid or duplicate options'),\n                createValidation(\n                    () => selList_unique.filter(str => str === optList[2] || str === optList[3]).length < 2,\n                    'One or more re-entry constructions have both options 2r and 2r+1 set at the same time'),\n            ];\n\n            return validations.every(validation => validation().cata({\n                error: e => { throw new Error(e); },\n                success: data => data,\n            }) );\n        }\n\n        return true;\n    }\n\n    static isValidJSONForm (input, options) {\n        /* Checks if an input is a valid JSON-FORM */\n        // const { } = { ...options };\n\n        const validations = [\n            createValidation(\n                () => true,\n                ''),\n        ];\n\n        return validations.every(validation => validation().cata({\n            error: e => { throw new Error(e); },\n            success: data => data,\n        }) );\n\n        return true;\n    }\n\n    static formMatchesVarList (form, varList) {\n        /* Checks if a given FORM matches a given variable list */\n        const varsForm = this.getVariables(form);\n\n        const match = varList.length === varsForm.length\n            && varsForm.every(v_a => varList.some(v_b => v_a === v_b));\n        if (!match) throw new Error('FORM doesn\\'t match the given variable list');\n\n        return true;\n    }\n\n    static getValidForm(input) {\n        if(typeof(input) === 'string') {\n            if (!this.isValidFormula(input)) throw new Error('Input is not a valid formula');\n            return this.parseLinear(input);\n        } else {\n            // >>> need to check json input too\n            return input;\n        }\n    }\n\n}","import calc from './core/fcalc';\nimport form from './core/fform';\nimport dna from './core/fdna';\n\nexport default { calc, form, dna };","import FForm from './fform';\nimport { permuteArray, pad, createValidation, equalArrays, getRandomBigInt } from 'formsandlines-utils';\n\nimport * as bigInt from 'big-integer'; // obsolete with better BigInt support in browsers\n\nexport default class FDna extends FForm {\n    \n    // ===================================================================\n    //     formform core module 'dna'\n    //     -- since 2019/20, by Peter Hofmann (formsandlines.eu)\n    // ===================================================================\n   \n    constructor() {\n    };\n\n    // ----------------------------------------------------\n    // Extensions of FFORM\n    // ----------------------------------------------------\n\n    static calcAll(input) {\n        /* extension to represent formDNA as FORM calculation */\n\n        if (input.includes('::') && this.isValidDNA(input)) {\n\n            const dna = input.split(':').pop();\n            const results = dna.split('').reverse();\n\n            const vnum = this.totalVarsFromDNA(dna);\n            const vars = Array.from({length: vnum}, (_, i) => `\"x_${i}\"` );\n            const vals = {};\n\n            if (vnum < 1) {\n                vals['Result'] = parseInt(results[0]);\n                return vals;\n            }\n\n            const interKey = ''+vars.join()+';';\n\n            for (let i=0; i < results.length; i++) {\n                const interprVals = pad(i.toString(4), vnum);\n                const interpr = interprVals.split('').map((val,n) => ({var: vars[n], value: parseInt(val)}));\n\n                vals[interKey+interprVals] = results[i];\n            }\n\n            return vals;\n        }\n\n        return super.calcAll(input);\n    }\n\n    static getVariables(input) {\n        /* extension to get variables from formDNA */\n\n        if (typeof(input) === 'string' && input.includes('::')) {\n            const { dna, formula, varList } = this.getDNAparts(input);\n\n            if (varList !== undefined) return varList;\n            else if (formula !== undefined) return super.getVariables(formula);\n\n            const vnum = this.totalVarsFromDNA(dna);\n            return Array.from({length: vnum}, (_, i) => `x_${i}` );\n        }\n\n        return super.getVariables(input);\n    }\n\n    // ----------------------------------------------------\n    // Conversions\n    // ----------------------------------------------------\n\n    static encode (_form, varorder=undefined) {\n        /* Encodes a FORM as a dna string */\n\n        const form = varorder ? this.reOrderVars(_form, varorder) : _form;\n\n        return Object.values(this.calcAll(form)).reverse().join('');\n     };\n\n// EXPERIMENTAL >\n\n     static decode (dna, varList=undefined) {\n        /* Decodes dna into (one of its) simplest corresponding FORM model(s) as a json-representation */\n\n\n        // -> remove 0-terms and groupings?\n\n        if (varList && varList.length !== this.totalVarsFromDNA(dna)) throw new Error('Number of variables in given variable list doesn\\'t match formDNA code length');\n        if (!varList) varList = this.generateVarNames(this.totalVarsFromDNA(dna)); //.map(str => `\"${str}\"`);\n        \n        const univ = this.universe_n(varList);\n        const vals = dna.split('').reverse();\n\n        return univ.map((term, i) => {\n            return `((${vals[i]})(${term}))`;\n        }).join('');\n     }\n\n// < END\n\n    static intToDNA (int, vnum) {\n        /* Takes an integer (usually BigInt) and a desired variable number and returns the corresponding formDNA \n\n        Note: variable number is needed because the intended number of leading zeros cannot be infered from the integer alone. If no variable number is given, the smallest variable number possible for the quaternion is assumed to generate valid formDNA. */\n\n        const quat = int.toString(4);\n        if (quat.substr(0,1) === '-') throw new Error('Negative integers cannot be converted to formDNA.');\n        if (quat.includes('.')) throw new Error('Fractional numbers cannot be converted to formDNA.')\n\n        const dnaLen = vnum ? 4**vnum : (function minDnaLen(strLen, n=0) { \n            return 4**n >= strLen ? 4**n : minDnaLen(strLen, n+1);\n        })(quat.length);\n\n        if (quat.length > dnaLen) throw new Error('Integer size exceeds desired DNA length.');\n        return pad(quat, dnaLen);\n    }\n\n    // ----------------------------------------------------\n    // Output\n    // ----------------------------------------------------\n\n    static formToDNA (input, varorder=undefined, options=undefined) {\n        /* converts a form into its formDNA representation in HTML */\n\n        const {output} = { output: undefined, ...options };\n\n        let dna = undefined, formula = undefined, varList = undefined;\n        if (input.includes('::')) {\n            // if the input contains the mark '::' for formDNA, return it if it's valid\n            if (!this.isValidDNA(input)) throw new Error('Input is not valid formDNA');\n\n            const parts = this.getDNAparts(input);\n\n            dna = parts.dna;\n            formula = parts.formula;\n            varList = parts.varList;\n        }\n        else {\n            // if not, process the input as a FORM with specified or default varorder and encode it to dna\n            dna = this.encode( input, (varorder ? varorder : undefined) );\n            formula = input;\n            varList = varorder ? varorder : this.getVariables(formula);\n        }\n\n        switch (output) {\n            // case 'html': {\n            // \treturn formDNA_html(formula, dna, varList);\n            // }\n            case 'text': {\n                return (formula !== undefined ? formula : '') + (varList && dna.length > 1 ? `.[${varList.join(',')}]` : '') + '::' + dna;\n            }\n            case 'num': {\n                return dna;\n            }\n            default: {\n                return [formula, varList, dna];\n            }\n        }\n    }\n\n    static dnaToFORM (formDNA, varorder=undefined, options=undefined) {\n        /* converts formDNA with a given variable list/order into a graph representation of (one of its) simplest corresponding FORM model(s) */\n\n        // >>> not yet implemented!\n\n        return this.decode(formDNA, varorder);\n    }\n\n    static genRandomDNA (vnum) {\n        /* Generates a random formDNA string for a given variable number */\n\n        const maxN = bigInt(4).pow( bigInt(4).pow(vnum) );\n        const value_bin = getRandomBigInt( maxN.subtract(1) );\n        return this.intToDNA(value_bin, vnum);\n    }\n\n    static vmap (input, varorder=undefined, options=undefined) {\n        /* generates vmap HTML from form/formDNA input */\n\n        const { limitSize, convDefaultVarorder,\n                size, gapGrow, marginFunc, strokeW } = {\n                    limitSize: true, convDefaultVarorder: true,\n                    size: undefined, gapGrow: 1.5, marginFunc: undefined, strokeW: 0.5,\n                    // filter: '1111', <- might add later\n                    ...options};\n\n        let dna = undefined;\n        let formula = input;\n\n        if (input.includes('::') && this.isValidDNA(input)) {\n            const dnaParts = this.getDNAparts(input);\n            dna = dnaParts.dna;\n            formula = dnaParts.formula;\n            const varList = dnaParts.varList ? dnaParts.varList : this.getVariables(input);\n\n            if (varorder !== undefined && varList !== undefined && !equalArrays(varorder, varList)) {\n                throw new Error('Variable order is specified in the formDNA input and as an argument for the vmap function and they are different. Please select only one specification to avoid conflicting results.');\n            }\n            else if (varList) {\n                varorder = varList;\n            } else if (formula) {\n                varorder = this.getVariables(formula);\n            }\n        }\n        else if (!varorder) {\n            varorder = this.getVariables(formula);\n            if (convDefaultVarorder) varorder = this.matchDefaultVarOrder(varorder);\n        }\n\n        if (!dna) dna = this.encode(formula, varorder);\n        const vnum = this.totalVarsFromDNA(dna);\n\n        if (vnum === NaN) throw new Error('Invalid variable number for vmaps.');\n        if (limitSize && vnum > 8) throw new Error('vmaps with more than 8 variables are too computationally intensive to be rendered with this implementation. If you still want to proceed, add the option \"limitSize: false\" to your vmap function call (using the formform library).');\n\n\n        const reversedDNA = dna.split('').reverse().join('');\n        \n        const cellSize = size || (vnum => {\n            // reduction by 2px for each additional variable if vnum > 3\n            const n = 17 - (vnum > 3 ? 2 * (vnum-3) : 0); // changed from: 14 - (vnum-1);\n            return Math.max(2, n); // min size of 2px\n        })(vnum);\n\n        // margins can also be calculated through a custom function\n        const margins = [strokeW, \n            ...Array.from({length:vnum-1}, marginFunc ? marginFunc : ((_,i) => (i+1) * gapGrow) )];\n        const cell = {w:cellSize, h:cellSize};\n\n\n        const vmapTree = this.constructVmap(reversedDNA, vnum, cell, margins);\n\n        return {tree: vmapTree,\n                input: input, \n                varorder: varorder, \n                options: options};\n    }\n\n    static vmapPerspectives (form, varorder=undefined, globalOptions=undefined, localOptions=undefined) {\n        /* Generates a list of vmap perspectives as permutations of a form/formDNA input */\n        // Note: formDNA input not yet supported (permutation algorithm required)\n\n        const {limitSize} = { limitSize: true, ...globalOptions };\n\n        if (typeof(form) === 'string' && form.includes('::')) throw new Error('formDNA input is not yet supported for vmap perspectives.');\n\n        if (varorder === undefined) varorder = this.matchDefaultVarOrder( this.getVariables(form) );\n        const vnum = varorder.length;\n        if (limitSize && vnum > 5) throw new Error('Rendering all the perspectives for vmaps with more than 5 variables is too computationally intensive with this implementation. You can, however, still compute single permutations by changing the variable order of your FORM. If you still want to proceed, add the option \"limitSize: false\" to your vmapPerspectives function call (using the formform library).');\n\n        const formula = form; // <<< support for JSON?\n\n        const vmapPermutations = permuteArray(varorder)\n            .map(varorder => this.vmap(formula, varorder, {\n                hideInputLabel: true, \n                customLabel: undefined,\n                ...localOptions }) );\n\n        return vmapPermutations;\n    }\n\n    static vmapList (inputList, globalOptions=undefined) {\n        /* Generates a list of vmaps from an array of FORM inputs */\n        // inputList format: [['form/formDNA', [varorder]/undefined, options/undefined], ...]\n\n        const vmaps = inputList.map(input => this.vmap(input[0], input[1], {...input[2], ...globalOptions}) );\n\n        return vmaps;\n    }\n\n    // ----------------------------------------------------\n    // Data Structure\n    // ----------------------------------------------------\n\n    static constructVmap (reversedDNA, vnum, cell, margins) {\n        /* Recursively constructs vmap data-structure from formDNA */\n\n        const calcGapSum = (v,margins) => margins.slice(1,v).reverse().reduce((acc,curr,idx) => acc + (2**idx) * curr, 0);\n        const fx = (qi,n) =>  (qi%2) * (n !== undefined ? n : 0);         // xpos: 0123 -> 0101 * shift n\n        const fy = (qi,n) => +(qi>0 && qi<3) * (n !== undefined ? n : 0); // ypos: 0123 -> 0110 * shift n\n\n        const constructVmap_recursive = (dnaHolon, vcount, cell, margins, qi=0) => {\n            const subTree = {};\n            const gapSum = calcGapSum(vcount,margins);\n            const qtn = 4**vcount;\n            const len = Math.sqrt(qtn);\n            dnaHolon = dnaHolon.substr(qi*qtn, qtn); // quarter of the formDNA string\n        \n            subTree.data = { \n                dna: '::'+dnaHolon.split('').reverse().join(''),\n                vnum: vcount, cell: cell,\n                margins: vnum > 0 ? margins.slice(0,vcount) : margins.slice(0,1)\n            };\n\n            subTree.height = vcount;\n            subTree.depth = vnum - (Math.log(qtn) / Math.log(4)); // log base 4\n            subTree.order = qi;\n        \n            subTree.position = [\n                // base shift  =  (1) cell size * length units  +  (2) sum of all previous gaps/margins\n                // real shift  =  base shift  +  (3) margins of current iteration level\n                // -- qi: current value index 0/1/2/3\n                // -- -- fx/fy map qi to x/y positions of a square and multiply by shift value (2. argument)\n                // -- margins: [strokeW, 1 * gapGrow, 2 * gapGrow,  (vnum-1) * gapGrow]\n                // -- -- if vcount == 0    -> shift (3) == strokeW\n                // -- -- if vcount == vnum -> shift (3) == 0\n                fx(qi, len*cell.w) + fx(qi, gapSum) + fx(qi, margins[vcount]),\n                fy(qi, len*cell.h) + fy(qi, gapSum) + fy(qi, margins[vcount])];\n\n            subTree.scale = [\n                len*cell.w + gapSum, \n                len*cell.h + gapSum ];\n\n            if (vnum === 0) { // if formDNA only has a single value, like ::3\n                subTree.value = dnaHolon;\n                return subTree;\n            }\n\n            subTree.children = [];\n        \n            for (let i=0; (vcount > 0 && i < 4) ||(vcount === 0 && i < 1); i++) {\n                if (vcount > 1) {\n                subTree.children = \n                    [...subTree.children, constructVmap_recursive(dnaHolon, vcount-1, cell, margins, i) ];\n                }\n                else {\n                const val = dnaHolon.substr(i,1);\n        \n                subTree.children = [...subTree.children, ({\n                    // type: 'value',\n                    data: {\n                        dna: '::'+val,\n                        vnum: 0, cell: cell,\n                        margins: margins.slice(0,1),\n                    },\n                    value: val,\n                    height: vcount-1,\n                    depth: subTree.depth + 1,\n                    order: i,\n                    // count: 1,\n                    position: [fx(i,cell.w), fy(i,cell.h)],\n                    scale: [cell.w, cell.h],\n                    // parent: subTree\n                }) ];\n                }\n            }\n          return subTree;\n        }\n        return constructVmap_recursive (reversedDNA, vnum, cell, margins);\n    }\n\n    // ----------------------------------------------------\n    // Validation\n    // ----------------------------------------------------\n\n    static dnaMatchesForm (dna, form, _varList=undefined, options) {\n        /* Checks if a given DNA code matches a given FORM (+ optional variable list) */\n        // const { } = { ...options };\n        const varList = _varList ? _varList : super.getVariables(form);\n\n        const validations = _varList ? [\n            createValidation(\n                () => this.formMatchesVarList(form, varList),\n                'FORM doesn\\'t match the given variable list'),\n            createValidation(\n                () => varList.length === this.totalVarsFromDNA(dna),\n                'Number of variables in given variable list doesn\\'t match formDNA code length'),\n            createValidation(\n                () => this.encode(form, varList) === dna,\n                'formDNA code is inconsistent with FORM interpretation results (respecting specified variable order)'),\n        ] : [\n            createValidation(\n                () => varList && varList.length === this.totalVarsFromDNA(dna),\n                'Number of FORM variables doesn\\'t match formDNA code length'),\n            createValidation(\n                () => this.encode(form) === dna,\n                'formDNA code is inconsistent with FORM interpretation results'),\n        ];\n\n        return validations.every(validation => validation().cata({\n            error: e => { throw new Error(e); },\n            success: data => data,\n        }) );\n\n        return true;\n    }\n\n    static isValidDNA (_input, options) {\n        /* Checks if an input is in formDNA format (has to be marked with '::' to not confuse it with a FORM out of constants) */\n        const {compareForm, requireMark} = { compareForm: true, requireMark: true, ...options };\n\n        const input = requireMark ? _input : '::'+_input;\n\n        const validations1 = [\n            createValidation(() => typeof(input) === 'string',\n                'formDNA input is not of type string'),\n            createValidation(() => input.includes('::'),\n                'Input does not include the mark :: for formDNA'),\n            createValidation(() => input.length >= 3,\n                'formDNA input is too short'),\n        ];\n        validations1.every(validation => validation().cata({\n            error: e => { throw new Error(e); },\n            success: data => data,\n        }) );\n\n        const { dna, formula, varList } = this.getDNAparts(input);\n        const validations2 = [\n            createValidation(() => this.totalVarsFromDNA(dna) >= 0,\n                'formDNA code length is not in the range 4^x'),\n            createValidation(() => !dna.split('').some(n => isNaN(parseInt(n)) || parseInt(n) < 0 || parseInt(n) > 3),\n                'formDNA code is not in quaternion format (consisting only of the numbers 0/1/2/3)'),\n            compareForm && formula !== undefined\n            ? createValidation(() => this.dnaMatchesForm(dna, formula, varList),\n                'formDNA code part doesn\\'t match formula part or formula part doesn\\'t match its specified variable order') : null,\n        ].filter(fn => fn);\n\n        validations2.every(validation => validation().cata({\n            error: e => { throw new Error(e); },\n            success: data => data,\n        }) );\n\n        return true;\n    }\n\n    // ----------------------------------------------------\n    // Helper\n    // ----------------------------------------------------\n\n// EXPERIMENTAL >\n\nstatic generateVarNames (vnum, excludeList = undefined) {\n    return Array.from({length: vnum}, (_, i) => {\n        let candidate = `x_${i}`;\n        if (excludeList !== undefined) {\n            while (excludeList.includes(candidate)) {\n                candidate = candidate+``;\n            }\n        }\n        return candidate;\n    });\n}\n\nstatic universe_1 (x) {\n    /* Returns the constituents of the 4-valued universe of 1 terms from a variable name */\n    if (x.length > 1) x = `\"${x}\"`;\n    return [ \n        `({(${x})}{2r|(${x})})`, \n        `({${x}}{2r|${x}})`, \n        `(({(${x})}${x})({2r|${x}}(${x})))`, \n        `(({${x}}(${x}))({2r|(${x})}${x}))`];\n}\n\nstatic universe_n (vars) {\n    /* Returns the constituents of the 4-valued universe of n terms from a list of n variable names */\n    const vnum = vars.length;\n    const univ1s = vars.map(v => this.universe_1(v));\n    return Array.from({length: 4**vnum}, (_, i) => {\n      const iq = pad(i.toString(4), vnum).split('');\n      const univN = univ1s.reduce((formula, univ1, j, arr) => \n                           formula+`(${univ1[iq[j]]})`\n                           +(j === arr.length-1 ? ')' : ''), '(');\n      return vnum > 1 ? univN : univN.slice(2,-2);\n    });\n};\n\n// < END\n\n    static totalVarsFromDNA (formDNA) { \n        /* Calculates variable number from formDNA */\n\n        // detach from formDNA mark '::'\n        const dna = formDNA.split(':').pop();\n\n        // calculate the number of variables from the lenght of the string\n        const n = Math.log(dna.length)/Math.log(4); // log_4(dna length) = variable number\n        return n % 1 === 0 ? n : NaN;\n    };\n\n    static repairDNA (input) {\n        /* Repairs a given string that is not in a valid formDNA form to pass as formDNA */\n\n        // if the input contains the mark '::' for formDNA, distinguish two cases\n        if (input.includes('::')) {\n            // Case 1: input is of form f.[x]::n or f::n -> f will be encoded as a FORM (with [x] as variable order, if it matches the FORMs variables in number and labels)\n            // - If the formDNA has been well formed in the first place, the output will be equivalent\n            // - If the dna part doesn't match the FORM part, the dna part will be corrected\n            // - If the variable order doesn't match the FORM variables, it will also be corrected\n            // Note that this case effectively interprets the input as FORM input and makes sure that the formDNA is consistent, because it is impossible to infer a FORM from its DNA.\n            const parts = this.getDNAparts(input);\n            if (parts.formula) {\n                // if there is a [x]-part, extract variable order and check if its valid for the FORM\n                let varList = undefined;\n                try { // try...catch avoids interruption by Error\n                    if (parts.varList && this.formMatchesVarList(parts.formula, parts.varList)) varList = parts.varList;\n                } catch (e) {\n                    console.error(e.message);\n                }\n                // re-encode to return correct formDNA for the given formula\n                return this.formToDNA(parts.formula, varList);\n            }\n            // Case 2: input is of form ::n -> the output will be the same\n            // Note that a FORM will not be decoded from the dna alone, since this FORM would be opinionated\n            if (!this.isValidDNA(input)) return null;\n\n            return input;\n        }\n        // if the input is not marked as formDNA, it will just be encoded as a FORM\n        return this.formToDNA(input);\n    }\n\n    static getDNAparts (formDNA) {\n        /* Decomposes a formDNA string into its 3/2/1 parts */\n        let dna = undefined, formula = undefined, varList = undefined;\n\n        const parts = formDNA.split(':');\n        dna = parts.pop();\n\n        if (parts[0].length > 0) {\n            const form_parts = parts[0].split('.');\n            formula = form_parts[0];\n            varList = form_parts.length > 1 ? form_parts[1].slice(1,-1).split(',') : varList;\n        }\n\n        return ({ dna: dna, formula: formula, varList: varList });\n    }\n\n}","import * as bigInt from 'big-integer';\n// const bigInt = require('big-integer');\n\nexport function bigIntToSciNotation(n, fractionDigits=2) { \n\t/* Scientific notation for BigInt numbers (needs some optimization) */\n\tconst nStr = n.toString(10);\n\tconst nLen = nStr.length;\n\tconst fraction = nLen-1 < 16 ? nLen-1 : 16;\n\tconst [wholes, parts] = [nStr.substr(0,1), nLen > 1 ? nStr.substr(1,fraction) : 0];\n\tlet nFloat = parseFloat(wholes+'.'+parts);\n\tnFloat = nFloat.toPrecision( (fractionDigits+1 > parts.length ? 2 : fractionDigits+1) );\n\treturn tex`\\approx ${nFloat} \\times 10^{${nLen-1}}`;\n}\n\nexport function getRandomBigInt(max) {\n\treturn bigInt.randBetween(0,max);\n}\n\n"],"sourceRoot":""}